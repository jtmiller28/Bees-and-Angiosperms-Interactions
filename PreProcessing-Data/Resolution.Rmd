---
title: "Resolution"
author: "JT Miller"
date: "2022-10-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### A markdown Comprised of the necessary step-by-step requirements to complete name resolution workflow ###

Requirements:
1) Pull in verbatim names for the combined GBIF & idigbio datasets (PLANTS)
2) Fix SN & Parsing Issues
3) Run Name List of just SN through Nomer, bring data into markdown 
4) Locate cases where there are multiple mappings for a given providedName, Determine which cases exhibit non n:1 mappings (where n = duplicate providedNames)
5) Run these cases back through nomer requiring Authorship
      * If authorship is not provided for any instance of a particular name, that name cannot be used in the analysis
      * If authorship is provided irregularly for a name with multiple mapping paths, then it should be flagged that Authorship is a requirement we Realign with sql. 
6) Deal with multiple Mapping failures
7) Create a Master Name Map Table
8) Remove name paths that are not included in Asteraceeae using the APG4 
9) Use SQL to Map all plant occurrences using the Master Name Map Table. 
10) Join corrected occurrence names into the GBIF & Idigbio non-verbatim datasets via a left join using occurrenceID as the key 

      
# Necessary Libraries 
```{r}
library(tidyverse)
library(sqldf)
library("rgnparser")
library(WorldFlora)
```

### Step 1: Bringing in verbatim name df from idigbio & gbif
```{r}
gbif_raw_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/GBIF-Pull/Uniform-Methods-Data-Pull/0018087-220831081235567/verbatim-names.txt", header = TRUE)

idigbio_raw_names <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/iDigBio-Pull/Uniform-Methods-Pull/ba15a9dd-d0ba-49ee-8477-7eccbd5a444d/sql-select.csv")

# Reformat data if necessary 
idigbio_raw_names <- idigbio_raw_names %>% 
  rename(dwc.genus = field77, dwc.infraspecificEpithet = field101, dwc.occurrenceID = field136, dwc.scientificName = field165, dwc.scientificNameAuthorship = field166, dwc.specificEpithet = field169)

# Removal of redudant row showing column headers 
idigbio_raw_names <- idigbio_raw_names[-1,]
```

### Step 2: Assuring Name Continuity 
```{r}
# Composition of names, authors, and occurrence ID 
idigbio_raw_names_SNless <- idigbio_raw_names %>% 
  filter(dwc.scientificName == "") # 5,477 names without a scientificName

idigbio_raw_names_gain <- idigbio_raw_names %>% 
  filter(dwc.scientificName == "" & !dwc.genus =="") %>%  # 1687
  filter(!dwc.specificEpithet == "") # Only 110 of these names are actually salvagable 

idigbio_raw_names_fixed <- idigbio_raw_names_gain %>% 
  mutate(dwc.scientificName = str_c(dwc.genus, ' ', dwc.specificEpithet)) # Salvage 

idigbio_raw_names_SN <- idigbio_raw_names %>% 
  filter(!dwc.scientificName == "") %>% 
  rbind(idigbio_raw_names_fixed) %>%  # Add in the salvaged names...
  rename(genus = dwc.genus, infraspecificEpithet = dwc.infraspecificEpithet, occurrenceID = dwc.occurrenceID, scientificName = dwc.scientificName, scientificNameAuthorship = dwc.scientificNameAuthorship, specificEpithet = dwc.specificEpithet) # Reformat names for combining dfs...

# Rinse and Repeat for GBIF 

# Composition of names, authors, and occurrence ID 
gbif_raw_names_SNless <- gbif_raw_names %>% 
  filter(scientificName == "") # 

gbif_raw_names_gain <- gbif_raw_names %>% 
  filter(scientificName == "" & !genus =="") %>%  
  filter(!specificEpithet == "") 

gbif_raw_names_fixed <- gbif_raw_names_gain %>% 
  mutate(scientificName = str_c(genus, ' ', specificEpithet)) # Salvage 

gbif_raw_names_SN <- gbif_raw_names %>% 
  filter(!scientificName == "") %>% 
  rbind(gbif_raw_names_fixed) # Add in the salvaged names...

# Bring the datasets together 
idigbio_s <- idigbio_raw_names_SN %>% 
  select(scientificName, scientificNameAuthorship) 

gbif_s <- gbif_raw_names_SN %>% 
  select(scientificName, scientificNameAuthorship)

raw_names_c <- rbind(idigbio_s, gbif_s)

# Deal with possible https in scientificName, as this will mess up parsing algorithms
raw_names_c <- raw_names_c %>% 
  filter(!grepl("https", scientificName))

# We want only distinct combinations of SN & Authors
raw_names_d <- raw_names_c %>% 
  distinct(scientificName, scientificNameAuthorship, .keep_all = TRUE)
```

## We want to run gn-parse on our names, considering cases where:
 1) Authorship was not provided, but possibly was embedded in the scientificName field 
 2) Authorship was provided, but also was possibly embedded in the scientficName field 
It seems important that we don't drop Authorships that were manually written, even if they differ from what was embedded in the SN. Therefore when realigning, prioritize initially written SN authorships and backfill with parsed authorships where possible. 
```{r}
# To do this lets firsst parse the names...
raw_names_d2 <- raw_names_d %>% 
  select(scientificName)

# Read data out into a tab-delimited txt file for nomer parsing 
write.table(raw_names_d2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/distinct-names-for-parsing.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in parsed names
parsed_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/parsed-names.txt", header = TRUE, quote = "") 

# Make it the same indexing as our parent raw_names_d 
parsed_names <- parsed_names[-1,]
rownames(parsed_names) = seq(length=nrow(parsed_names))

# Reaffix to previous df, keeping in mind that if authorship was included in the previous df we want to use that and if not to include the authorship from parsed_names. In all cases we want the parsed_names resolvedName 


name_table <- cbind(raw_names_d, parsed_names)

name_table2 <- name_table

# Create an if-else statement, if ScientificNameAuthorship was not filled out by the providers, then look at the resolvedAuthorship column that was broken out by gn-parse. If there is a value there then append it to scientificNameAuthorship. 
name_table2$scientificNameAuthorship <- ifelse(name_table2$scientificNameAuthorship == "", name_table2$resolvedAuthorship, name_table2$scientificNameAuthorship) 

# Simplify Parsed Name Table 
name_table_c <- name_table2 %>% 
  select(resolvedName, scientificNameAuthorship) %>% 
  rename(scientificName = resolvedName)

```

## Step 3: Run through Nomer for first round of resolution while only considering SN 
```{r}
# Only consider SN for this run through Nomer 
name_table_SN <- select(name_table_c, scientificName)

# Write it out for Nomer...
write.table(name_table_SN, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-for-Resolution.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in Nomer's Input...
resolved_SN <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-Resolution.txt", header = TRUE, quote = "") 

resolved_SNF <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-Resolution-fams.txt", header = TRUE, quote = "")


# Get rid of Redundant first row, Grab only names that can map for now. 
resolved_SN2 <- resolved_SN %>% 
  filter(!providedName == "scientificName") %>% 
  filter(!relationName == "NONE")

# Set aside NONE resolutions for WFO online tool resolution
failed_names <- resolved_SN %>% 
  filter(relationName == "NONE")

# Find these with their authors in our name_table_c
failed_names_v <- failed_names$providedName

name_table_fails <- name_table_c %>% 
  filter(scientificName %in% failed_names_v)

# Write out failed names to a file so that we can send it to the hypergator for resolution...
write.table(name_table_fails, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-names.txt", row.names = FALSE, sep="\t", quote = FALSE)
```

## Step 4: Locate instances of multiple mappings:
  1) In the case of multiple names mapping to the SAME name, thats fine and should be maintained for our final Name Map
      ex: providedName        providedAuthorship            acceptedName        acceptedAuthorship
          Quercus fagaceae    L.                            Quercus fagaceae    L.
          Quercus fagaceae                                  Quercus fagaceae    
      
*Here its important to note that ANY authorship provided is fine. (this alleviates small cases of character mismatch in authorship)
      
  2) In the case of multiple names mapping to DIFFERENT names, thats something that can cause problems therefore we know that Authorship IS needed in order to determine mappings  
    ex: providedName        providedAuthorship            acceptedName                  acceptedAuthorship
        Quercus fagaceae    L.                            Quercus fagaceae              L.
        Quercus fagaceae    Jimmy                         Quercus fagaceae var. jillen  Jimmy
        Quercus fagaceae                                  Quercus fagaceae                    

*Here, its important to note that in cases where authorship IS NOT provided, we cant use this name...its ambigious and unclear therefore should result in throwing the data out. 
```{r}
# Identify instances where there are multiple of the same provided name...
multiple_mappings <- resolved_SN2 %>% 
  group_by(providedName) %>% 
  filter(n() > 1) # if there is more than one instance grab it 

not_multiple_mappings <- resolved_SN2 %>% 
  group_by(providedName) %>% 
  filter(!n() > 1) # if there is more than one instance grab it 

# Identify instances where these multiples are going to same resolvedName,
multiple_mappings_s <- multiple_mappings %>%
  group_by(providedName) %>% 
  filter(n_distinct(resolvedName) == 1) # Grab only times that the number of distinct matches in resolvedName = 1

# Interesting...seems we have a lot of cases of duplicates, not sure where in the workflow this was introduced. Possible remedy by very end is using distinct the final mapping? 

# Identify instances where these multiples are going to different resolvedNames...
multiple_mappings_d <- multiple_mappings %>% 
  group_by(providedName) %>% 
  filter(!n_distinct(resolvedName) == 1) # Grab only time that the number of distinct matches in resolvedName =/= 1

# Grab these names that map differently and subset our initial name_table_c by them
mult_map_different_name_v <- multiple_mappings_d$providedName

name_table_c_mult_mappings <- name_table_c %>% 
  filter(scientificName %in% mult_map_different_name_v) # Note: will have a smaller amount due to non-multiples being in name_table_c

# Drop names on the condition that they do not include necessary authorship...too ambiguous to be useful for our mapping. 
new_table_c_mult_mappings_w_a <- name_table_c_mult_mappings %>% 
  filter(!scientificNameAuthorship == "")
```

## Step 5: Send these different resolution mapping names through Nomer with the inclusion of authorship. 
```{r}
# Write out the df for nomer resolution...
write.table(new_table_c_mult_mappings_w_a, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/mult-mapping-names.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in the resolution...
resolved_mult_maps <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/mult-mapping-names-resolution.txt", header = TRUE, quote = "") 

# Successes?
corrected_mult_maps <- resolved_mult_maps %>% 
  filter(!relationName == "NONE")


# Failures? 
failed_mult_maps <- resolved_mult_maps %>% 
  filter(relationName == "NONE")
```

## Step 6: Dealing with the failures. This is a tricky scenario where we dont want to let fuzzy matching get carried away and map our name to the other option. 
However, from visual inspection of the data it becomes obvious that some of these failures to map are just due to small character misalignment between the WFO catalogue and inputted authorship.
Ex. Erigeron ursinus D.C. Eaton -> will map to NONE, however: Erigeron ursinus D.C.Eaton -> will map correctly to it being an accepted species.
...note there are alot of ways this author is written...


Solution: Use WFO.one tool to map based upon Authorship as the priority in the matching scheme. 
```{r}
# Manually pick the taxonomic backbone to match against 
WFO.file.rk <- file.choose()
# Create a df since WFO tool is temperamental 
spec.name <- failed_mult_maps$providedName
Authorship <- failed_mult_maps$providedAuthorship
failed_mults_df <- data.frame(spec.name, Authorship)

failed_mults_checked <- WFO.match(failed_mults_df, 
                                  WFO.file = WFO.file.rk,
                                  spec.name = "spec.name",
                                  Authorship = "Authorship",
                                  counter = 100)

# Run with WFO.one which will give us the best matches 
failed_mults_res <- WFO.one(WFO.result = failed_mults_checked,
                            verbose = FALSE,
                            Auth.dist = "Auth.dist", # Prioritize Least Author Distance
                            counter = 100)


write.csv(failed_mults_res,"/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-multiples-resolved.csv", row.names = FALSE )
```



Dealing with Special Cases in Failed Name Resolution (1) 
```{r}
failed_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-names.txt", header = TRUE, quote = "")

failed_names_d <- failed_names %>% 
  distinct(scientificName, scientificNameAuthorship) # Make sure theyre distinct

# Remove anything that is only to genus...

failed_names_d_sp <- failed_names_d[grepl(" ", failed_names_d$scientificName),]
failed_names_d_sp2 <- failed_names_d_sp[!grepl("unknown", failed_names_d_sp$scientificName),]
failed_names_d_sp3 <- failed_names_d_sp2[!grepl("\\?", failed_names_d_sp2$scientificName),]

# Replace all ssp. with subsp. to match WorldFlora's catalogue

failed_names_d_sp4 <- failed_names_d_sp3 %>% 
  mutate(scientificName = str_replace(scientificName, "ssp.", "subsp."))

failed_subsp <- failed_names_d_sp4 %>% 
  filter(grepl("subsp.", scientificName)) # These can be processed seperately 

failed_subsp2 <- failed_subsp %>% 
  select(scientificName)

write.table(failed_subsp2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed_subsp.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Grab names w/out notation change 
failed_noNotationC <- failed_names_d_sp4 %>% 
  filter(!grepl("subsp.", scientificName))
# Write them out 


# Read in Nomer resolved Subsp. changes 
subsp_res <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp-resolution.txt", header = TRUE, quote = "") 

# Filter out NONE resolutions 

subsp_res_fails <- subsp_res %>% 
  filter(NONE == "NONE") %>% # 3775 failures 
  distinct(scientificName, .keep_all = TRUE)

# Sync these failures back up with their authors...Put aside for WFO tool resolution. 
subsp_fails_v<- subsp_res_fails$scientificName

table_subsp_fails <- failed_names_d_sp4 %>% 
  filter(scientificName %in% subsp_fails_v) # Combine these for WFO tool resolution

downstream_fails <- rbind(failed_noNotationC, table_subsp_fails)
write.table(downstream_fails, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/downstream-fails.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Successes 
subsp_res_pass <- subsp_res %>%
  filter(!NONE == "NONE")

# Multiple Mappings?
multiple_mappings_subsp <- subsp_res_pass %>% 
  group_by(scientificName) %>% 
  filter(n() > 1) # Set these aside for resolution!!!

unique_mappings_subsp <- subsp_res_pass %>% 
  group_by(scientificName) %>% 
  filter(!n() > 1) # These will be included in final name table !!!

# Multiple Mappings result in the SAME name 
multiple_mappings_subsp_r <- multiple_mappings_subsp %>%
  group_by(scientificName) %>% 
  filter(n_distinct(scientificName.1) == 1) # These will be included in final name table !!!

# Multiple Mappings result in DIFFERENT names 
multiple_mappings_subsp_unk <- multiple_mappings_subsp %>%
  group_by(scientificName) %>% 
  filter(!n_distinct(scientificName.1) == 1)

subsp_unk_multmaps_v <- multiple_mappings_subsp_unk$scientificName

# Rematch mult maps that could cause problems...
table_subsp_mult_maps_unk <- failed_names_d_sp4 %>% 
  filter(scientificName %in% subsp_unk_multmaps_v) %>% 
  filter(!scientificNameAuthorship == "") # Cant use ambigious names

### Write out to Nomer for resolution w/authorship
write.table(table_subsp_mult_maps_unk, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp_multMap.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in Nomer resolution
subsp_multmaps_resolved <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp-multMap-res.txt", header = TRUE, quote = "")

# Keep Successes 
subsp_multmaps_resolved_successes <- subsp_multmaps_resolved %>% 
  filter(!relationName == "NONE") # These will be included in final name table  !!!

# Send the failures through WFO tool with authorship priority 
subsp_multmaps_resolved_failures <- subsp_multmaps_resolved %>% 
  filter(relationName == "NONE")

# Manually pick the taxonomic backbone to match against 
WFO.file.rk <- file.choose()
# Create a df since WFO tool is temperamental 
spec.name <- subsp_multmaps_resolved_failures$providedName
Authorship <- subsp_multmaps_resolved_failures$providedAuthorship
failed_mults_subsp_df <- data.frame(spec.name, Authorship)

failed_mults_subsp_checked <- WFO.match(failed_mults_subsp_df, 
                                  WFO.file = WFO.file.rk,
                                  spec.name = "spec.name",
                                  Authorship = "Authorship",
                                  counter = 100)

# Run with WFO.one which will give us the best matches 
failed_mults_subsp_res <- WFO.one(WFO.result = failed_mults_subsp_checked,
                            verbose = FALSE,
                            Auth.dist = "Auth.dist", # Prioritize Least Author Distance
                            counter = 100)

# It seems that failure can occur when author name provided is exceedingly short and unreliable for resolution. Example is Briq. which seems to have multiple possible mapping values

briq_ex <- failed_mults_subsp_res[5,]
# Check other resolution method...
briq_ex_r <- WFO.one(WFO.result = briq_ex,
                            verbose = FALSE,
                            # Prioritize Least Author Distance
                            counter = 100)

# Too ambigious...they used the subsp. of the other name while denoting it with the author of the other, therefore we're throwing it out...

failed_mults_subsp_res <- failed_mults_subsp_res %>% 
  filter(!Authorship == "Briq.") # Set aside for name-table !!!
```
## Step 6.5: Bring in the names that failed the initial Nomer Resolution and didn't contain authorship
```{r}
# Bring in the resolution of downstream fail names dfs 
dsf_names1 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf_checked1.csv")
dsf_names2 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked2.csv")
dsf_names3 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked3.csv")
dsf_names4 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked4.csv")


# Use WFO.one to run through names 
dsf_res1 <- WFO.one(WFO.result = dsf_names1,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res2 <- WFO.one(WFO.result = dsf_names2,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res3 <- WFO.one(WFO.result = dsf_names3,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res4 <- WFO.one(WFO.result = dsf_names4,
                            verbose = FALSE,
  
                            counter = 1000)

dsf_res <- rbind(dsf_res1, dsf_res2, dsf_res3, dsf_res4)

# Check for duplicates at the intersections
dsf_res %>% 
  group_by(spec.name, Authorship) %>% 
  filter(n_distinct(spec.name) == 2) # Appears things worked.

write.csv(dsf_res, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution.csv", row.names = FALSE )

# Now lets only consider Angiosperms before applying filtering protocol 
angio_fams <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Angiosperm-Family-Key/only-fams3-apg4.txt", header = FALSE)

angio_fams_v <- angio_fams$V1 # Grab a vector list of the angiosperm families 

# Now subset the resolution for only finding family that is contained within known angiosperms
dsf_res_angios <- dsf_res %>% 
  filter(family %in% angio_fams_v) # Lost somewhere between 2 and 3 thousand names

```

## Step 6.9: Filter fuzzy matched names 
Filter requirements: We want names that were not modified to a large extent, unless they are synonomous names which can have large character replacement. 
```{r}
dsf_res_angios_f <- dsf_res_angios %>% 
  filter(Fuzzy.dist <= 10 | Old.status == "SYNONYM")

write.csv(dsf_res_angios_f, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution-fullFiltered.csv", row.names = FALSE)
```


## Step 7: Bring Names together In a Mapping Table 
```{r}
# Should be all of the dfs that will build our Final Mapping Table. 
not_multiple_mappings
multiple_mappings_s
corrected_mult_maps
failed_mults_res <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-multiples-resolved.csv")
unique_mappings_subsp
multiple_mappings_subsp_r
subsp_multmaps_resolved_successes
failed_mults_subsp_res
# AND ONE MORE! 

dsf_res_angios_f <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution-fullFiltered.csv")



# So Take all Nomer resolved data -> Compile a dataframe -> Seperate dataframe -> Run Through WFO.match with no Fuzzy on the resolved name -> Grab Family 

nomer_resolved_dfs <- rbind(not_multiple_mappings, multiple_mappings_s, corrected_mult_maps, unique_mappings_subsp, multiple_mappings_subsp_r, subsp_multmaps_resolved_successes)

nomer_resolved_dfs2 <- nomer_resolved_dfs %>% 
  select(providedName, relationName, resolvedExternalId, resolvedName, resolvedAuthorship, resolvedRank)

# Make it into a broken reformatted df since wfo's fxns are very particular
providedName <- nomer_resolved_dfs2$providedName
relationName <- nomer_resolved_dfs2$relationName
resolvedExternalId <- nomer_resolved_dfs2$resolvedExternalId
resolvedName <- nomer_resolved_dfs2$resolvedName
resolvedAuthorship <- nomer_resolved_dfs2$resolvedAuthorship
resolvedRank <- nomer_resolved_dfs2$resolvedRank

nomer_res_df <- data.frame(providedName, relationName, resolvedExternalId, resolvedName, resolvedAuthorship, resolvedRank)

nomer_res_df2 <- nomer_res_df %>% 
  distinct(providedName, relationName, resolvedName, resolvedAuthorship)

write.csv(nomer_res_df2, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/nomer_resolutions_need_fams.csv", row.names = FALSE)

nomer_matched <- WFO.match(nomer_res_df,
                             WFO.file = WFO.file.rk,
                             spec.name = "resolvedName",
                             Authorship = "resolvedAuthorship",
                             Fuzzy = 0)


resolvedName <- multiple_mappings_subset$resolvedName
resolvedAuthorship <- multiple_mappings_subset$resolvedAuthorship

test_df <- data.frame(resolvedName, resolvedAuthorship)

test <- WFO.match(test_df, 
                                  WFO.file = WFO.file.rk,
                                  spec.name = "resolvedName",
                                  Authorship = "resolvedAuthorship",
                                  counter = 100, 
                                  Fuzzy = 0)

mult_map_fams <- WFO.family(multiple_mappings_subset$resolvedName, WFO.file = WFO.file.rk)

not_mult_map


# Build the table 
final_name_table <- rbind(not_multiple_mappings, multiple_mappings_s, corrected_mult_maps, failed_mults_res, unique_mappings_subsp, multiple_mappings_subsp_r, subsp_multmaps_resolved_successes, failed_mults_subsp_res, dsf_res_angios_f)
```

### Reformat Nomer Names for Fixing... ###
```{r}
nomer_names_need_fams <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/nomer_resolutions_need_fams.csv")

nomer_names_need_fams3 <- nomer_names_need_fams %>% 
  distinct(providedName, relationName, resolvedName, resolvedAuthorship)
# Grab only the resolved Names for Nomer matching sequence
nomer_names_need_fams2 <- nomer_names_need_fams %>% 
  select(resolvedName) %>% 
  

# Ran through nomer...with properties adjusted to add family name
write.table(nomer_names_need_fams2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/names_need_fams_nomer_RNO.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in the names 
nomer_names_w_fams <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/names_w_families_nomer_res.txt", header = TRUE)

# Looks like we'll need to use our SQL query to attach family names to these. First lets make a nomer_fname_table 
nomer_fname_table <- nomer_names_w_fams %>% 
  rename(family = resolvedPath.family.name) %>% 
  select(providedName, resolvedName, family)

# We only want distinct combinations 
nomer_fname_table2 <- nomer_fname_table %>% 
  distinct(providedName, resolvedName, family)

# Remap names to include their families 
names_remapped <- sqldf("SELECT dataset.*, real_name_map.resolvedNames 
FROM sample_df dataset 
LEFT JOIN (SELECT DISTINCT sub_dataset.scientificName, MAX(sub_real_names.acceptedNames) resolvedNames
    FROM sample_df sub_dataset
    LEFT JOIN sample_mapping_table sub_real_names ON sub_dataset.scientificName = sub_real_names.verbatimScientificNames
    GROUP BY sub_dataset.scientificName) real_name_map ON dataset.scientificName = real_name_map.scientificName")

```

