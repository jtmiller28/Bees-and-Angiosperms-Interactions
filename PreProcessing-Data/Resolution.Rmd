---
title: "Resolution"
author: "JT Miller"
date: "2022-10-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### A markdown Comprised of the necessary step-by-step requirements to complete name resolution workflow ###

Requirements:
1) Pull in verbatim names for the combined GBIF & idigbio datasets (PLANTS)
2) Fix SN & Parsing Issues
3) Run Name List of just SN through Nomer, bring data into markdown 
4) Locate cases where there are multiple mappings for a given providedName, Determine which cases exhibit non n:1 mappings (where n = duplicate providedNames)
5) Run these cases back through nomer requiring Authorship
      * If authorship is not provided for any instance of a particular name, that name cannot be used in the analysis
      * If authorship is provided irregularly for a name with multiple mapping paths, then it should be flagged that Authorship is a requirement we Realign with sql. 
6) Deal with multiple Mapping failures
7) Create a Master Name Map Table
8) Remove name paths that are not included in Asteraceeae using the APG4 
9) Use SQL to Map all plant occurrences using the Master Name Map Table. 
10) Join corrected occurrence names into the GBIF & Idigbio non-verbatim datasets via a left join using occurrenceID as the key 

      
# Necessary Libraries 
```{r}
library(tidyverse)
library(sqldf)
library("rgnparser")
library(WorldFlora)
```

### Step 1: Bringing in verbatim name df from idigbio & gbif
```{r}
gbif_raw_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/GBIF-Pull/Uniform-Methods-Data-Pull/0018087-220831081235567/verbatim-names.txt", header = TRUE)

idigbio_raw_names <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/iDigBio-Pull/Uniform-Methods-Pull/ba15a9dd-d0ba-49ee-8477-7eccbd5a444d/sql-select.csv")

# Reformat data if necessary 
idigbio_raw_names <- idigbio_raw_names %>% 
  rename(dwc.genus = field77, dwc.infraspecificEpithet = field101, dwc.occurrenceID = field136, dwc.scientificName = field165, dwc.scientificNameAuthorship = field166, dwc.specificEpithet = field169)

# Removal of redudant row showing column headers 
idigbio_raw_names <- idigbio_raw_names[-1,]
```

### Step 2: Assuring Name Continuity 
```{r}
# Composition of names, authors, and occurrence ID 
idigbio_raw_names_SNless <- idigbio_raw_names %>% 
  filter(dwc.scientificName == "") # 5,477 names without a scientificName

idigbio_raw_names_gain <- idigbio_raw_names %>% 
  filter(dwc.scientificName == "" & !dwc.genus =="") %>%  # 1687
  filter(!dwc.specificEpithet == "") # Only 110 of these names are actually salvagable 

idigbio_raw_names_fixed <- idigbio_raw_names_gain %>% 
  mutate(dwc.scientificName = str_c(dwc.genus, ' ', dwc.specificEpithet)) # Salvage 

idigbio_raw_names_SN <- idigbio_raw_names %>% 
  filter(!dwc.scientificName == "") %>% 
  rbind(idigbio_raw_names_fixed) %>%  # Add in the salvaged names...
  rename(genus = dwc.genus, infraspecificEpithet = dwc.infraspecificEpithet, occurrenceID = dwc.occurrenceID, scientificName = dwc.scientificName, scientificNameAuthorship = dwc.scientificNameAuthorship, specificEpithet = dwc.specificEpithet) # Reformat names for combining dfs...

# Rinse and Repeat for GBIF 

# Composition of names, authors, and occurrence ID 
gbif_raw_names_SNless <- gbif_raw_names %>% 
  filter(scientificName == "") # 

gbif_raw_names_gain <- gbif_raw_names %>% 
  filter(scientificName == "" & !genus =="") %>%  
  filter(!specificEpithet == "") 

gbif_raw_names_fixed <- gbif_raw_names_gain %>% 
  mutate(scientificName = str_c(genus, ' ', specificEpithet)) # Salvage 

gbif_raw_names_SN <- gbif_raw_names %>% 
  filter(!scientificName == "") %>% 
  rbind(gbif_raw_names_fixed) # Add in the salvaged names...

# Bring the datasets together 
idigbio_s <- idigbio_raw_names_SN %>% 
  select(scientificName, scientificNameAuthorship, occurrenceID) 

gbif_s <- gbif_raw_names_SN %>% 
  select(scientificName, scientificNameAuthorship, occurrenceID)

raw_names_c <- rbind(idigbio_s, gbif_s)

# Deal with possible https in scientificName, as this will mess up parsing algorithms
raw_names_c <- raw_names_c %>% 
  filter(!grepl("https", scientificName))
# Write out csv for resolution
write.csv(raw_names_c, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/combined_verbatim_occurrences.csv", row.names = FALSE)

write.table(raw_names_c, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/combined_verbatim_occurrences.txt", row.names = FALSE, sep="\t", quote = FALSE)
# We want only distinct combinations of SN & Authors
raw_names_d <- raw_names_c %>% 
  distinct(scientificName, scientificNameAuthorship, .keep_all = TRUE)

```

## We want to run gn-parse on our names, considering cases where:
 1) Authorship was not provided, but possibly was embedded in the scientificName field 
 2) Authorship was provided, but also was possibly embedded in the scientficName field 
It seems important that we don't drop Authorships that were manually written, even if they differ from what was embedded in the SN. Therefore when realigning, prioritize initially written SN authorships and backfill with parsed authorships where possible. 
```{r}
# To do this lets firsst parse the names...
raw_names_d2 <- raw_names_d %>% 
  select(scientificName)

# Read data out into a tab-delimited txt file for nomer parsing 
write.table(raw_names_d2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/distinct-names-for-parsing.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in parsed names
parsed_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/parsed-names.txt", header = TRUE, quote = "") 

# Make it the same indexing as our parent raw_names_d 
parsed_names <- parsed_names[-1,]
rownames(parsed_names) = seq(length=nrow(parsed_names))

# Reaffix to previous df, keeping in mind that if authorship was included in the previous df we want to use that and if not to include the authorship from parsed_names. In all cases we want the parsed_names resolvedName 


name_table <- cbind(raw_names_d, parsed_names)

name_table2 <- name_table

# Create an if-else statement, if ScientificNameAuthorship was not filled out by the providers, then look at the resolvedAuthorship column that was broken out by gn-parse. If there is a value there then append it to scientificNameAuthorship. 
name_table2$scientificNameAuthorship <- ifelse(name_table2$scientificNameAuthorship == "", name_table2$resolvedAuthorship, name_table2$scientificNameAuthorship) 

# Simplify Parsed Name Table 
name_table_c <- name_table2 %>% 
  select(resolvedName, scientificNameAuthorship) %>% 
  rename(scientificName = resolvedName)

```

## Step 3: Run through Nomer for first round of resolution while only considering SN 
```{r}
# Only consider SN for this run through Nomer 
name_table_SN <- select(name_table_c, scientificName)

# Write it out for Nomer...
write.table(name_table_SN, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-for-Resolution.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in Nomer's Input...
resolved_SN <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-Resolution-fams.txt", header = TRUE, quote = "") 

# Was checking if these are the same, feel free to ignore
resolved_SNF <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/SN-Resolution-fams.txt", header = TRUE, quote = "")


# Get rid of Redundant first row, Grab only names that can map for now. 
resolved_SN2 <- resolved_SN %>% 
  filter(!providedName == "scientificName") %>% 
  filter(!relationName == "NONE")

# Set aside NONE resolutions for WFO online tool resolution
failed_names <- resolved_SN %>% 
  filter(relationName == "NONE")

# Find these with their authors in our name_table_c
failed_names_v <- failed_names$providedName

name_table_fails <- name_table_c %>% 
  filter(scientificName %in% failed_names_v)

# Write out failed names to a file so that we can send it to the hypergator for resolution...
write.table(name_table_fails, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-names.txt", row.names = FALSE, sep="\t", quote = FALSE)
```

## Step 4: Locate instances of multiple mappings:
  1) In the case of multiple names mapping to the SAME name, thats fine and should be maintained for our final Name Map
      ex: providedName        providedAuthorship            acceptedName        acceptedAuthorship
          Quercus fagaceae    L.                            Quercus fagaceae    L.
          Quercus fagaceae                                  Quercus fagaceae    
      
*Here its important to note that ANY authorship provided is fine. (this alleviates small cases of character mismatch in authorship)
      
  2) In the case of multiple names mapping to DIFFERENT names, thats something that can cause problems therefore we know that Authorship IS needed in order to determine mappings  
    ex: providedName        providedAuthorship            acceptedName                  acceptedAuthorship
        Quercus fagaceae    L.                            Quercus fagaceae              L.
        Quercus fagaceae    Jimmy                         Quercus fagaceae var. jillen  Jimmy
        Quercus fagaceae                                  Quercus fagaceae                    

*Here, its important to note that in cases where authorship IS NOT provided, we cant use this name...its ambigious and unclear therefore should result in throwing the data out. 
```{r}
# Identify instances where there are multiple of the same provided name...
multiple_mappings <- resolved_SN2 %>% 
  group_by(providedName) %>% 
  filter(n() > 1) # if there is more than one instance grab it 

not_multiple_mappings <- resolved_SN2 %>% 
  group_by(providedName) %>% 
  filter(!n() > 1) # if there is more than one instance grab it 

# Identify instances where these multiples are going to same resolvedName,
multiple_mappings_s <- multiple_mappings %>%
  group_by(providedName) %>% 
  filter(n_distinct(resolvedName) == 1) # Grab only times that the number of distinct matches in resolvedName = 1

# Interesting...seems we have a lot of cases of duplicates, not sure where in the workflow this was introduced. Possible remedy by very end is using distinct the final mapping? 

# Identify instances where these multiples are going to different resolvedNames...
multiple_mappings_d <- multiple_mappings %>% 
  group_by(providedName) %>% 
  filter(!n_distinct(resolvedName) == 1) # Grab only time that the number of distinct matches in resolvedName =/= 1

# Grab these names that map differently and subset our initial name_table_c by them
mult_map_different_name_v <- multiple_mappings_d$providedName

name_table_c_mult_mappings <- name_table_c %>% 
  filter(scientificName %in% mult_map_different_name_v) # Note: will have a smaller amount due to non-multiples being in name_table_c

# Drop names on the condition that they do not include necessary authorship...too ambiguous to be useful for our mapping. 
new_table_c_mult_mappings_w_a <- name_table_c_mult_mappings %>% 
  filter(!scientificNameAuthorship == "")
```

## Step 5: Send these different resolution mapping names through Nomer with the inclusion of authorship. 
```{r}
# Write out the df for nomer resolution...
write.table(new_table_c_mult_mappings_w_a, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/mult-mapping-names.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in the resolution...
resolved_mult_maps <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/mult-mapping-names-resolved-wfams.txt", header = TRUE, quote = "") 


# Successes?  
corrected_mult_maps <- resolved_mult_maps %>% 
  filter(!relationName == "NONE")


# Failures? 
failed_mult_maps <- resolved_mult_maps %>% 
  filter(relationName == "NONE")
```

## Step 6: Dealing with the failures. This is a tricky scenario where we dont want to let fuzzy matching get carried away and map our name to the other option. 
However, from visual inspection of the data it becomes obvious that some of these failures to map are just due to small character misalignment between the WFO catalogue and inputted authorship.
Ex. Erigeron ursinus D.C. Eaton -> will map to NONE, however: Erigeron ursinus D.C.Eaton -> will map correctly to it being an accepted species.
...note there are alot of ways this author is written...


Solution: Use WFO.one tool to map based upon Authorship as the priority in the matching scheme. 
```{r}
# Manually pick the taxonomic backbone to match against 
WFO.file.rk <- file.choose()
# Create a df since WFO tool is temperamental 
spec.name <- failed_mult_maps$providedName
Authorship <- failed_mult_maps$providedAuthorship
failed_mults_df <- data.frame(spec.name, Authorship)

failed_mults_checked <- WFO.match(failed_mults_df, 
                                  WFO.file = WFO.file.rk,
                                  spec.name = "spec.name",
                                  Authorship = "Authorship",
                                  counter = 100)

# Run with WFO.one which will give us the best matches 
failed_mults_res <- WFO.one(WFO.result = failed_mults_checked,
                            verbose = FALSE,
                            Auth.dist = "Auth.dist", # Prioritize Least Author Distance
                            counter = 100)


write.csv(failed_mults_res,"/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-multiples-resolved.csv", row.names = FALSE )
```



Dealing with Special Cases in Failed Name Resolution (1) 
```{r}
failed_names <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-names.txt", header = TRUE, quote = "")

failed_names_d <- failed_names %>% 
  distinct(scientificName, scientificNameAuthorship) # Make sure theyre distinct

# Remove anything that is only to genus...

failed_names_d_sp <- failed_names_d[grepl(" ", failed_names_d$scientificName),]
failed_names_d_sp2 <- failed_names_d_sp[!grepl("unknown", failed_names_d_sp$scientificName),]
failed_names_d_sp3 <- failed_names_d_sp2[!grepl("\\?", failed_names_d_sp2$scientificName),]

# Replace all ssp. with subsp. to match WorldFlora's catalogue

failed_names_d_sp4 <- failed_names_d_sp3 %>% 
  mutate(scientificName = str_replace(scientificName, "ssp.", "subsp."))

failed_subsp <- failed_names_d_sp4 %>% 
  filter(grepl("subsp.", scientificName)) # These can be processed seperately 

failed_subsp2 <- failed_subsp %>% 
  select(scientificName)

write.table(failed_subsp2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed_subsp.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Grab names w/out notation change 
failed_noNotationC <- failed_names_d_sp4 %>% 
  filter(!grepl("subsp.", scientificName))
# Write them out 


# Read in Nomer resolved Subsp. changes 
subsp_res <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp-resolution.txt", header = TRUE, quote = "")

# Filter out NONE resolutions 

subsp_res_fails <- subsp_res %>% 
  filter(relationName == "NONE") %>% # 3775 failures 
  distinct(providedName, .keep_all = TRUE)

# Sync these failures back up with their authors...Put aside for WFO tool resolution. 
subsp_fails_v<- subsp_res_fails$scientificName

table_subsp_fails <- failed_names_d_sp4 %>% 
  filter(scientificName %in% subsp_fails_v) # Combine these for WFO tool resolution

downstream_fails <- rbind(failed_noNotationC, table_subsp_fails)
write.table(downstream_fails, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/downstream-fails.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Successes 
subsp_res_pass <- subsp_res %>%
  filter(!relationName == "NONE")

# Multiple Mappings?
multiple_mappings_subsp <- subsp_res_pass %>% 
  group_by(providedName) %>% 
  filter(n() > 1) # Set these aside for resolution!!!

unique_mappings_subsp <- subsp_res_pass %>% 
  group_by(providedName) %>% 
  filter(!n() > 1) # These will be included in final name table !!!

# Multiple Mappings result in the SAME name 
multiple_mappings_subsp_r <- multiple_mappings_subsp %>%
  group_by(providedName) %>% 
  filter(n_distinct(resolvedName) == 1) # These will be included in final name table !!!

# Multiple Mappings result in DIFFERENT names 
multiple_mappings_subsp_unk <- multiple_mappings_subsp %>%
  group_by(providedName) %>% 
  filter(!n_distinct(resolvedName) == 1)

subsp_unk_multmaps_v <- multiple_mappings_subsp_unk$scientificName

# Rematch mult maps that could cause problems...
table_subsp_mult_maps_unk <- failed_names_d_sp4 %>% 
  filter(scientificName %in% subsp_unk_multmaps_v) %>% 
  filter(!scientificNameAuthorship == "") # Cant use ambigious names

### Write out to Nomer for resolution w/authorship
write.table(table_subsp_mult_maps_unk, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp_multMap.txt", row.names = FALSE, sep="\t", quote = FALSE)

# Read in Nomer resolution
subsp_multmaps_resolved <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/subsp-multMap-res-wfams.txt", header = TRUE, quote = "")


# Keep Successes 
subsp_multmaps_resolved_successes <- subsp_multmaps_resolved %>% 
  filter(!relationName == "NONE") # These will be included in final name table  !!!

# Send the failures through WFO tool with authorship priority 
subsp_multmaps_resolved_failures <- subsp_multmaps_resolved %>% 
  filter(relationName == "NONE")

# Manually pick the taxonomic backbone to match against 
WFO.file.rk <- file.choose()
# Create a df since WFO tool is temperamental 
spec.name <- subsp_multmaps_resolved_failures$providedName
Authorship <- subsp_multmaps_resolved_failures$providedAuthorship
failed_mults_subsp_df <- data.frame(spec.name, Authorship)

failed_mults_subsp_checked <- WFO.match(failed_mults_subsp_df,
                                  WFO.file = WFO.file.rk,
                                  spec.name = "spec.name",
                                  Authorship = "Authorship",
                                  counter = 100)

# Run with WFO.one which will give us the best matches 
failed_mults_subsp_res <- WFO.one(WFO.result = failed_mults_subsp_checked,
                            verbose = FALSE,
                            Auth.dist = "Auth.dist", # Prioritize Least Author Distance
                            counter = 100)

# It seems that failure can occur when author name provided is exceedingly short and unreliable for resolution. Example is Briq. which seems to have multiple possible mapping values

briq_ex <- failed_mults_subsp_res[5,]
# Check other resolution method...
briq_ex_r <- WFO.one(WFO.result = briq_ex,
                            verbose = FALSE,
                            # Prioritize Least Author Distance
                            counter = 100)

# Too ambigious...they used the subsp. of the other name while denoting it with the author of the other, therefore we're throwing it out...

failed_mults_subsp_res <- failed_mults_subsp_res %>% 
  filter(!Authorship == "Briq.") # Set aside for name-table !!!
```
## Step 6.5: Bring in the names that failed the initial Nomer Resolution and didn't contain authorship
```{r}
# Bring in the resolution of downstream fail names dfs 
dsf_names1 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf_checked1.csv")
dsf_names2 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked2.csv")
dsf_names3 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked3.csv")
dsf_names4 <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-checked4.csv")


# Use WFO.one to run through names 
dsf_res1 <- WFO.one(WFO.result = dsf_names1,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res2 <- WFO.one(WFO.result = dsf_names2,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res3 <- WFO.one(WFO.result = dsf_names3,
                            verbose = FALSE,
  
                            counter = 1000)
# Use WFO.one to run through names 
dsf_res4 <- WFO.one(WFO.result = dsf_names4,
                            verbose = FALSE,
  
                            counter = 1000)

dsf_res <- rbind(dsf_res1, dsf_res2, dsf_res3, dsf_res4)

# Check for duplicates at the intersections
dsf_res %>% 
  group_by(spec.name, Authorship) %>% 
  filter(n_distinct(spec.name) == 2) # Appears things worked.

write.csv(dsf_res, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution.csv", row.names = FALSE )

# Read it in
dsf_res <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution.csv")
# Now lets only consider Angiosperms before applying filtering protocol 
angio_fams <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Angiosperm-Family-Key/only-fams3-apg4.txt")
#write.table(angio_fams, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Angiosperm-Family-Key/only-fams3-apg4.txt", sep="\t", quote = FALSE)
angio_fams_v <- angio_fams$V1 # Grab a vector list of the angiosperm families 

# Now subset the resolution for only finding family that is contained within known angiosperms
dsf_res_angios <- dsf_res %>% 
  filter(family %in% angio_fams_v | family == "Viburnaceae" | family == "Parnassiaceae") # Lost somewhere between 2 and 3 thousand names

```

## Step 6.9: Filter fuzzy matched names 
Filter requirements: We want names that were not modified to a large extent, unless they are synonomous names which can have large character replacement. 
```{r}
dsf_res_angios_f <- dsf_res_angios %>% 
  filter(Fuzzy.dist <= 10 | Old.status == "SYNONYM")

write.csv(dsf_res_angios_f, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution-fullFiltered.csv", row.names = FALSE)
```


## Step 7: Bring Names together In a Mapping Table 
```{r}
# Should be all of the dfs that will build our Final Mapping Table. 
not_multiple_mappings
multiple_mappings_s
corrected_mult_maps
failed_mults_res <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/failed-multiples-resolved.csv")
unique_mappings_subsp
multiple_mappings_subsp_r
subsp_multmaps_resolved_successes
failed_mults_subsp_res
# AND ONE MORE! 

dsf_res_angios_f <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/dsf-resolution-fullFiltered.csv")
# One last edit here 
dsf_res_angios_ff <- dsf_res_angios_f %>% 
  filter(!taxonomicStatus == "DOUBTFUL"| !taxonomicStatus == "") # Get rid of doubtful taxonomic status

# Check if this df built from the failures has instances of multiple mappings. 
# Multiple Mappings?
dsf_res_mult_maps <- dsf_res_angios_ff %>% 
  group_by(spec.name) %>% 
  filter(n() > 1) 
# Check for instances where these mult maps lead to a unique name 
dsf_res_mult_maps_s <- dsf_res_mult_maps %>%
  group_by(spec.name) %>% 
  filter(n_distinct(scientificName) == 1) # Appears that all are singular mappings therefore this step proves to be non-effective 


#### Combining all Nomer Resolved Names #### 
nomer_resolutions <- rbind(not_multiple_mappings, multiple_mappings_s, corrected_mult_maps, unique_mappings_subsp, multiple_mappings_subsp_r, subsp_multmaps_resolved_successes)

# Remove duplicates
nomer_resolutions_d <- nomer_resolutions %>% 
  distinct(providedName, resolvedName, resolvedAuthorship, resolvedPath.family.name, .keep_all = TRUE)

# There are instances where family wasnt included with designation. To solve this lets use a exact matching scheme in the WFO tool to match names of a plant family. (Also this would make a great issue for Nomer)
famless_according_to_nomer <- nomer_resolutions_d %>% 
  filter(resolvedPath.family.name == "" | is.na(resolvedPath.family.name)) # Find all of these instances 

# Set aside ones that do include family 
nomer_w_fams <- nomer_resolutions_d %>% 
  filter(!resolvedPath.family.name == "") %>% 
  filter(!is.na(resolvedPath.family.name)) %>% 
  rename(family = resolvedPath.family.name) 

# Use WFO's tool to find the family names of the ones Nomer missed. 
resolvedName <- famless_according_to_nomer$resolvedName
resolvedAuthorship <- famless_according_to_nomer$resolvedAuthorship
famless_df <- data.frame(resolvedName, resolvedAuthorship)
WFO.file.rk <- file.choose()

fam_rec_names <- WFO.match(famless_df, 
                                  WFO.file = WFO.file.rk,
                                  spec.name = "resolvedName",
                                  Authorship = "resolvedAuthorship",
                                  counter = 100, 
                                  Fuzzy = 0) # Makes it where there is NO fuzzys

# Only take the correct names
fam_rec_names_one <- WFO.one(WFO.result = fam_rec_names,
                            verbose = FALSE,counter = 1000)


# Get rid of taxonomic uncertainy records, then organize for distinct records + rename for clarity in merging datasets

fam_rec_names_d <- fam_rec_names_one  %>% 
  filter(!taxonomicStatus == "DOUBTFUL" | !taxonomicStatus == "") %>% # We don't want those known as doubtful nor ones with taxonomicStatus left blank
  distinct(resolvedName, resolvedAuthorship, scientificName, scientificNameAuthorship, .keep_all = TRUE) %>% # Take only distinct values for all of the values
  select(resolvedName, resolvedAuthorship, scientificName, family, taxonRank) %>% # Select the important columns for our table
  rename(providedName = resolvedName, resolvedName = scientificName, resolvedRank = taxonRank) # Rename them for bringing the dfs together. 

# Rebind these familyless and w/family records. 
nomer_w_fams <- nomer_w_fams %>% 
  select(resolvedName, resolvedAuthorship, resolvedRank, providedAuthorship, family)
nomer_w_fams2 <- rbind(nomer_w_fams, fam_rec_names_d)


#### Reformat the other data to match headers of nomer output
wfo_resolved_names <- rbind(failed_mults_res, failed_mults_subsp_res, dsf_res_angios_ff)

wfo_resolved_names_reform <- wfo_resolved_names %>% 
  filter(!taxonomicStatus == "DOUBTFUl" | !taxonomicStatus == "") %>% 
  select(spec.name, Authorship, scientificName, scientificNameAuthorship, taxonRank, family) %>% 
  rename(providedName = spec.name, resolvedName = scientificName,  resolvedAuthorship = scientificNameAuthorship, resolvedRank = taxonRank, providedAuthorship = Authorship)

# Populate Nomer with a scientificNameAuthorship base column 
name_table <- wfo_resolved_names_reform %>% 
  rbind(nomer_w_fams2) 

### Remove non-angiosperms 

# Grab names from APG4 publication
angio_fams <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Angiosperm-Family-Key/only-fams3-apg4.txt", header = TRUE)

angio_fams_v <- angio_fams$V1 # Grab a vector list of the angiosperm families 

# Remove from our table
name_table_angios <- name_table %>% 
  filter(family %in% angio_fams_v | family == "Viburnaceae" | family == "Parnassiaceae") # 2,962 mappings removed 

name_table_angios_d <- name_table_angios %>% 
  distinct(providedName, providedAuthorship, resolvedName, resolvedAuthorship, resolvedRank, family, .keep_all = TRUE) # 475 mappings removed 

### We dont want anything only defined to the Species level or below
name_table_angios_s <- name_table_angios_d
name_table_angios_s$resolvedRank <- tolower(name_table_angios_s$resolvedRank) # Mesh the notation difference between nomer and wfo's tool on Rank

name_table_angios_sp <- name_table_angios_s %>% 
  filter(resolvedRank == "species" | resolvedRank == "variety" | resolvedRank == "subspecies") # Only grab these designations, disclude those that only go ot > genus or are ambigious. Drops 4,291 records 

# Change name table to match template
final_name_table <- name_table_angios_sp %>% 
  rename(verbatimScientificNames = providedName) %>% 
  rename(verbatimAuthorship = providedAuthorship) %>% 
  rename(acceptedNames = resolvedName) %>% 
  rename(acceptedAuthorship = resolvedAuthorship)
```

```{r}
# Write out name table
write.csv(final_name_table, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/final_name_table.csv", row.names = FALSE)
```

# Final Resolution 
Here, we will LEFT JOIN our occurrence data with the final name table, allowing us to resolve all scientific names provided accordingly. 
* This should remove designations that are not known in our name table
* This shoudld be conditional upon multiple mapping instances, where authorship is necessary in order to arrive at the correct designation. 
      -> This means that we will be breaking our final mapping table into two different parts 
            1) A unique mapping table: A mapping table where all names will arrive at the accepted resolved name W/out need of authorship
            2) A non-unique mapping table: A mapping table where names are ambiguous by SN alone, and therefore will need to include the conditional of                      authorship in order to correctly arrive at designation. 
```{r}
# Read in mapping table...
final_name_table <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/final_name_table.csv")

# Step 1) Splitting the mapping table

#Find all unique Mappings
unique_mapping_table <- final_name_table %>% 
  group_by(verbatimScientificNames) %>% 
  filter(n_distinct(acceptedNames) == 1) 

# Find all Non-unique Mappings
nonUnique_mapping_table <- final_name_table %>% 
   group_by(verbatimScientificNames) %>% 
  filter(!n_distinct(acceptedNames) == 1)

# Step 2) Bring in occurrence data for LEFT JOINING

# Read in data 
occurrence_df <- read.csv("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/combined_verbatim_occurrences.csv")

# Make occurrence ID a unique value, and assure that there is one provided at all
occurrence_df2 <- occurrence_df %>% 
  distinct(occurrenceID, .keep_all = TRUE)  %>% # Only unique occurrenceIDs are acceptable
  filter(!occurrenceID == "") %>% # Remove instances where this field is blank
  filter(!is.na(occurrenceID)) # Remove instances where this field is NA 

write.table(occurrence_df2, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/combined_verbatim_occurrences_filtered.txt", row.names = FALSE, sep="\t", quote = FALSE)
  
# Note that the data is currently unparsed in its SN field, we will need to use NOMER GN-PARSE in order to parse names, while retaining occurrenceID with the designations.  
# Used: cat combined_verbatim_occurrences_filtered.txt  |sed 's/^/\t/g' | nomer append gn-parse --properties my.properties3 > combined_verbatim_occurrences_parsed.txt

occur_parsed <- read.delim("/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/combined_verbatim_occurrences_parsed.txt", quote = "")

# Testing for timing and litnus test 
occur_df <- occur_parsed

occur_df2 <- occur_df %>%  
  rename(providedName = scientificName, providedAuthorship = scientificNameAuthorship, scientificName = scientificName.1, parsedAuthorship = X.2) %>%
  select(providedName, providedAuthorship, scientificName, parsedAuthorship, occurrenceID)

# Use an if else statement to create a Authorship column that pulls from what the provider wrote OR alternatively what was parsed 

occur_df2$providedAuthorship <- ifelse(occur_df2$providedAuthorship == "", occur_df2$parsedAuthorship, occur_df2$providedAuthorship)

# Clean up to only include whats necessary...
occur_df3 <- occur_df2 %>% 
  select(providedAuthorship, scientificName, occurrenceID) %>% 
  rename(authorship = providedAuthorship) %>% 
  relocate(authorship, .after = scientificName)

# AND apply the Notational Changes for catalogue (ssp. -> subsp.)
occur_df4 <- occur_df3 %>% 
  mutate(scientificName = str_replace(scientificName, "ssp.", "subsp."))

names_remapped <- sqldf("SELECT dataset.*, real_name_map.resolvedNames 
FROM occur_df4 dataset 
LEFT JOIN (SELECT DISTINCT sub_dataset.scientificName, MAX(sub_real_names.acceptedNames) resolvedNames
    FROM occur_df4 sub_dataset
    LEFT JOIN unique_mapping_table sub_real_names ON sub_dataset.scientificName = sub_real_names.verbatimScientificNames
    GROUP BY sub_dataset.scientificName) real_name_map ON dataset.scientificName = real_name_map.scientificName")

# Grab all of the names that failed to map
name_fails <- names_remapped %>% 
  filter(is.na(resolvedNames)) 

# We can only consider ones that have authorship written for resolution against multiple mappings
name_fails_w_authors <- name_fails %>% 
  filter(!authorship == "")

# And apply the non-unique resolution

names_remapped_auths <- sqldf("SELECT dataset.*,
			real_names.acceptedNames
			
FROM 		name_fails_w_authors dataset
LEFT JOIN 	nonUnique_mapping_table real_names ON dataset.scientificName = real_names.verbatimScientificNames

WHERE		(
				real_names.acceptedNames =	(
												SELECT		MAX(sub_real_names.acceptedNames)
												
												FROM		nonUnique_mapping_table sub_real_names
												
												WHERE		dataset.scientificName = sub_real_names.verbatimScientificNames
												AND 	
												  		dataset.authorship = acceptedAuthorship
                       OR 
                              dataset.authorship = verbatimAuthorship
              GROUP BY	sub_real_names.verbatimScientificNames) )")

names_remapped_auths_d <- names_remapped_auths %>% 
  distinct(scientificName, authorship, occurrenceID, acceptedNames )

# Bring together in a final df 
part_res_df <- names_remapped

names_remapped_auths_d2 <- names_remapped_auths_d %>% 
  rename(resolvedNames = acceptedNames)

full_res_df <- part_res_df  %>% 
  filter(!is.na(resolvedNames)) %>% 
  rbind(names_remapped_auths_d2) # It appears that we have 9,212,674 records out of the original 10,183,059 records after name reconsilation. (otherwords we lost 970,385 records due to naming)

tst <- full_res_df %>% 
  filter(scientificName == "Agrostis tenuis") # Just to check multimapping functioning, appears to be working perfectly. 
```

# Write it out to a txt and csv -> Send it to another script to join with post-processed data
```{r}
write.csv(full_res_df, "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/Resolved_verbatim.csv", row.names = FALSE)

write.table(full_res_df, file = "/home/jt-miller/Globi-Bees-Plant-Interactions/Plant-Data/Nomer-wfo-resolution/Final-Resolution/Resolved_verbatim.txt", row.names = FALSE, sep="\t", quote = FALSE)
```



